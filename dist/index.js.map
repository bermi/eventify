{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "/* Eventify v3 - type-safe, schema-optional */\n\nexport type EventMap = Record<string, unknown>;\n\nexport type PayloadArgs<T> = [T] extends [void]\n  ? []\n  : [T] extends [undefined]\n    ? []\n    : T extends readonly unknown[]\n      ? T\n      : [T];\n\n// #1: PayloadValue removed (was identity type: both branches returned T)\n\nexport type EventName<Events extends EventMap> = Extract<keyof Events, string>;\n\nexport type EventHandler<T> = (...args: PayloadArgs<T>) => unknown;\n\nexport type AllHandler<Events extends EventMap> = (\n  event: EventName<Events>,\n  ...args: unknown[]\n) => unknown;\n\nexport type EventHandlerMap<Events extends EventMap> = {\n  [K in keyof Events]?: EventHandler<Events[K]>;\n};\n\nexport type SchemaLike<T = unknown> =\n  | { parse: (input: unknown) => T }\n  | {\n      safeParse: (\n        input: unknown,\n      ) => { success: true; data: T } | { success: false; error: unknown };\n    };\n\nexport type SchemaMap = Record<string, SchemaLike>;\n\nexport type InferSchema<S> = S extends { parse: (input: unknown) => infer T }\n  ? T\n  : S extends {\n        safeParse: (input: unknown) => { success: true; data: infer T };\n      }\n    ? T\n    : unknown;\n\nexport type EventsFromSchemas<TSchemas> = TSchemas extends SchemaMap\n  ? { [K in keyof TSchemas]: InferSchema<TSchemas[K]> }\n  : EventMap;\n\nexport type ValidationMeta = { event: string };\n\nexport type SchemaValidator<TSchema extends SchemaLike = SchemaLike> = (\n  schema: TSchema,\n  payload: unknown,\n  meta: ValidationMeta,\n) => unknown;\n\nexport type ErrorMeta<Events extends EventMap> = {\n  event: EventName<Events> | string;\n  args: unknown[];\n  listener?: (...args: unknown[]) => unknown;\n  emitter: object;\n};\n\nexport type ErrorHandler<Events extends EventMap> = (\n  error: unknown,\n  meta: ErrorMeta<Events>,\n) => void;\n\nexport type EventifyOptions<\n  TSchemas extends SchemaMap | undefined = undefined,\n  TEvents extends EventMap = EventMap,\n> = {\n  schemas?: TSchemas;\n  validate?: SchemaValidator;\n  onError?: ErrorHandler<TEvents>;\n  namespaceDelimiter?: string;\n  wildcard?: string;\n};\n\nexport type IterateOptions = {\n  signal?: AbortSignal;\n};\n\nexport interface EventifyEmitter<Events extends EventMap = EventMap> {\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | EventListenerOptions,\n  ): void;\n  dispatchEvent(event: Event): boolean;\n\n  on<K extends EventName<Events>>(\n    name: K,\n    callback: EventHandler<Events[K]>,\n    context?: unknown,\n  ): this;\n  on(name: \"all\", callback: AllHandler<Events>, context?: unknown): this;\n  on(name: EventHandlerMap<Events>, context?: unknown): this;\n  on(\n    name: string,\n    callback?: (...args: unknown[]) => unknown,\n    context?: unknown,\n  ): this;\n\n  once<K extends EventName<Events>>(\n    name: K,\n    callback: EventHandler<Events[K]>,\n    context?: unknown,\n  ): this;\n  once(name: \"all\", callback: AllHandler<Events>, context?: unknown): this;\n  once(name: EventHandlerMap<Events>, context?: unknown): this;\n  once(\n    name: string,\n    callback?: (...args: unknown[]) => unknown,\n    context?: unknown,\n  ): this;\n\n  off(): this;\n  off<K extends EventName<Events>>(\n    name: K,\n    callback?: EventHandler<Events[K]> | null,\n    context?: unknown,\n  ): this;\n  off(name: EventHandlerMap<Events>, context?: unknown): this;\n  off(\n    name?: string | null,\n    callback?: ((...args: unknown[]) => unknown) | null,\n    context?: unknown,\n  ): this;\n\n  trigger<K extends EventName<Events>>(\n    name: K,\n    ...args: PayloadArgs<Events[K]>\n  ): this;\n  trigger(name: string, ...args: unknown[]): this;\n  emit<K extends EventName<Events>>(\n    name: K,\n    ...args: PayloadArgs<Events[K]>\n  ): this;\n  emit(name: string, ...args: unknown[]): this;\n  produce<K extends EventName<Events>>(\n    name: K,\n    ...args: PayloadArgs<Events[K]>\n  ): this;\n  produce(name: string, ...args: unknown[]): this;\n\n  listenTo<OtherEvents extends EventMap, K extends EventName<OtherEvents>>(\n    other: EventifyEmitter<OtherEvents>,\n    name: K,\n    callback: EventHandler<OtherEvents[K]>,\n  ): this;\n  listenTo<OtherEvents extends EventMap>(\n    other: EventifyEmitter<OtherEvents>,\n    name: EventHandlerMap<OtherEvents>,\n  ): this;\n  listenTo(\n    other: EventifyEmitter<EventMap>,\n    name: string,\n    callback?: (...args: unknown[]) => unknown,\n  ): this;\n\n  listenToOnce<OtherEvents extends EventMap, K extends EventName<OtherEvents>>(\n    other: EventifyEmitter<OtherEvents>,\n    name: K,\n    callback: EventHandler<OtherEvents[K]>,\n  ): this;\n  listenToOnce<OtherEvents extends EventMap>(\n    other: EventifyEmitter<OtherEvents>,\n    name: EventHandlerMap<OtherEvents>,\n  ): this;\n  listenToOnce(\n    other: EventifyEmitter<EventMap>,\n    name: string,\n    callback?: (...args: unknown[]) => unknown,\n  ): this;\n\n  stopListening<OtherEvents extends EventMap>(\n    other?: EventifyEmitter<OtherEvents> | null,\n    name?: EventName<OtherEvents> | EventHandlerMap<OtherEvents> | null,\n    callback?: ((...args: unknown[]) => unknown) | null,\n  ): this;\n\n  iterate<K extends EventName<Events>>(\n    name: K,\n    options?: IterateOptions,\n  ): AsyncIterableIterator<Events[K]>;\n  iterate(\n    name: \"all\",\n    options?: IterateOptions,\n  ): AsyncIterableIterator<[EventName<Events>, ...unknown[]]>;\n  iterate(\n    name: string,\n    options?: IterateOptions,\n  ): AsyncIterableIterator<unknown>;\n}\n\nexport interface EventifyStatic<\n  Events extends EventMap = EventMap,\n> extends EventifyEmitter<Events> {\n  version: string;\n  enable<TTarget extends object, TSchemas extends SchemaMap>(\n    target: TTarget | undefined,\n    options: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & {\n      schemas: TSchemas;\n    },\n  ): TTarget & EventifyEmitter<EventsFromSchemas<TSchemas>>;\n  enable<\n    TTarget extends object,\n    TEvents extends EventMap = EventMap,\n    TSchemas extends SchemaMap | undefined = undefined,\n  >(\n    target?: TTarget,\n    options?: EventifyOptions<TSchemas, TEvents>,\n  ): TTarget & EventifyEmitter<TEvents>;\n  create<TSchemas extends SchemaMap>(\n    options: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & {\n      schemas: TSchemas;\n    },\n  ): EventifyEmitter<EventsFromSchemas<TSchemas>>;\n  create<\n    TEvents extends EventMap = EventMap,\n    TSchemas extends SchemaMap | undefined = undefined,\n  >(\n    options?: EventifyOptions<TSchemas, TEvents>,\n  ): EventifyEmitter<TEvents>;\n  mixin: EventifyStatic[\"enable\"];\n  proto: EventifyEmitter<EventMap>;\n  defaultSchemaValidator: SchemaValidator;\n}\n\ntype AnyCallback = (...args: unknown[]) => unknown;\ntype AnyEmitter = EventifyEmitter<EventMap>;\n\ntype CallbackWithOriginal = AnyCallback & {\n  _callback?: AnyCallback;\n};\n\n// #12: context = user-provided value for identity matching in off()\n//      bound   = resolved execution context (context ?? emitter) for .apply()\ntype ListenerEntry = {\n  callback: CallbackWithOriginal;\n  context?: unknown;\n  bound: unknown;\n};\n\n// #4: Single pattern type (removed PrefixPatternEntry fast path)\ntype PatternEntry = ListenerEntry & {\n  pattern: string;\n  segments: string[];\n  trailingWildcard: boolean;\n};\n\ntype EmitterState = {\n  events: Map<string, ListenerEntry[]>;\n  patterns: PatternEntry[];\n  all: ListenerEntry[];\n  listeningTo: Set<AnyEmitter>;\n  target: EventTarget;\n  dispatchers: Map<string, EventListener>;\n  // #5: Simplified from Map<string, Set<EventListenerOrEventListenerObject>>.\n  // Conservative one-way set: names are added on addEventListener, never removed.\n  nativeEvents: Set<string>;\n  schemas: SchemaMap | undefined;\n  validate: SchemaValidator | undefined;\n  onError: ErrorHandler<EventMap>;\n  namespaceDelimiter: string;\n  wildcard: string;\n};\n\nconst eventSplitter = /\\s+/;\nconst eventifyArgsKey: unique symbol = Symbol(\"eventifyArgs\");\nconst eventifyListenersKey: unique symbol = Symbol(\"eventifyListeners\");\n\ntype EventifyCustomEvent = CustomEvent<unknown> & {\n  [eventifyArgsKey]?: unknown[];\n  [eventifyListenersKey]?: ListenerEntry[];\n};\n\nconst stateByEmitter = new WeakMap<object, EmitterState>();\n\nfunction noop(): void {}\n\nfunction reportError(\n  state: EmitterState,\n  error: unknown,\n  meta: ErrorMeta<EventMap>,\n): void {\n  try {\n    state.onError?.(error, meta);\n  } catch {\n    // Swallow error handler failures to avoid crashes.\n  }\n}\n\nfunction isPromiseLike(value: unknown): value is PromiseLike<unknown> {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    typeof (value as PromiseLike<unknown>).then === \"function\"\n  );\n}\n\nfunction safeCall(\n  state: EmitterState,\n  callback: CallbackWithOriginal,\n  bound: unknown,\n  args: unknown[],\n  meta: ErrorMeta<EventMap>,\n): void {\n  try {\n    const result = callback.apply(bound, args);\n    if (isPromiseLike(result)) {\n      result.then(undefined, (error: unknown) =>\n        reportError(state, error, meta),\n      );\n    }\n  } catch (error) {\n    reportError(state, error, meta);\n  }\n}\n\nfunction getEventArgs(event: Event): unknown[] {\n  const customEvent = event as EventifyCustomEvent;\n  const stored = customEvent[eventifyArgsKey];\n  if (stored) {\n    return stored;\n  }\n  if (\"detail\" in customEvent) {\n    const detail = (customEvent as CustomEvent<unknown>).detail;\n    if (detail === undefined) {\n      return [];\n    }\n    return Array.isArray(detail) ? detail : [detail];\n  }\n  return [];\n}\n\nfunction createEvent(name: string, args: unknown[]): CustomEvent<unknown> {\n  const detail = args.length <= 1 ? args[0] : args;\n  const event = new CustomEvent(name, { detail }) as EventifyCustomEvent;\n  Object.defineProperty(event, eventifyArgsKey, {\n    value: args,\n    enumerable: false,\n  });\n  return event;\n}\n\n// #6: Returns true when `name` is a single event string (caller should proceed).\n// Returns false when object-map or space-delimited events were already dispatched.\ntype EventApiAction = \"on\" | \"once\" | \"off\" | \"trigger\";\nfunction eventsApi(\n  obj: AnyEmitter,\n  action: EventApiAction,\n  name: unknown,\n  rest: unknown[],\n): boolean {\n  if (!name) {\n    return true;\n  }\n  const target = obj as EventifyEmitter<EventMap>;\n  const method = target[action] as (...args: unknown[]) => unknown;\n  if (typeof name === \"object\") {\n    for (const key in name as Record<string, unknown>) {\n      if (Object.prototype.hasOwnProperty.call(name, key)) {\n        method.call(\n          target,\n          key,\n          (name as Record<string, unknown>)[key],\n          ...rest,\n        );\n      }\n    }\n    return false;\n  }\n  if (typeof name === \"string\" && eventSplitter.test(name)) {\n    for (const eventName of name.split(eventSplitter)) {\n      method.call(target, eventName, ...rest);\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function defaultSchemaValidator(\n  schema: SchemaLike,\n  payload: unknown,\n  _meta: ValidationMeta,\n): unknown {\n  if (schema && typeof (schema as { parse?: unknown }).parse === \"function\") {\n    return (schema as { parse: (input: unknown) => unknown }).parse(payload);\n  }\n  if (\n    schema &&\n    typeof (schema as { safeParse?: unknown }).safeParse === \"function\"\n  ) {\n    const result = (\n      schema as {\n        safeParse: (input: unknown) => {\n          success: boolean;\n          data?: unknown;\n          error?: unknown;\n        };\n      }\n    ).safeParse(payload);\n    if (result && result.success) {\n      return result.data;\n    }\n    throw result?.error ?? new Error(\"Schema validation failed\");\n  }\n  throw new TypeError(\"Schema validator missing parse/safeParse\");\n}\n\nfunction getState(target: object, options?: EventifyOptions): EmitterState {\n  let state = stateByEmitter.get(target);\n  if (!state) {\n    const created: EmitterState = {\n      events: new Map(),\n      patterns: [],\n      all: [],\n      listeningTo: new Set(),\n      target: new EventTarget(),\n      dispatchers: new Map(),\n      nativeEvents: new Set(),\n      schemas: options?.schemas,\n      validate: options?.validate,\n      onError: options?.onError ?? noop,\n      namespaceDelimiter: options?.namespaceDelimiter ?? \"/\",\n      wildcard: options?.wildcard ?? \"*\",\n    };\n    if (options?.schemas && !created.validate) {\n      created.validate = defaultSchemaValidator;\n    }\n    stateByEmitter.set(target, created);\n    return created;\n  }\n  if (options) {\n    if (options.schemas) {\n      state.schemas = options.schemas;\n      if (!state.validate) {\n        state.validate = defaultSchemaValidator;\n      }\n    }\n    if (options.validate) {\n      state.validate = options.validate;\n    }\n    if (options.onError) {\n      state.onError = options.onError;\n    }\n    if (options.namespaceDelimiter) {\n      state.namespaceDelimiter = options.namespaceDelimiter;\n    }\n    if (options.wildcard) {\n      state.wildcard = options.wildcard;\n    }\n  }\n  return state;\n}\n\nfunction getExistingState(target: object): EmitterState | undefined {\n  return stateByEmitter.get(target);\n}\n\nfunction normalizeValidatedArgs(\n  state: EmitterState,\n  event: string,\n  args: unknown[],\n): unknown[] {\n  if (!state.schemas) {\n    return args;\n  }\n  const schema = state.schemas[event];\n  if (!schema) {\n    return args;\n  }\n  const validator = state.validate ?? defaultSchemaValidator;\n  if (args.length === 0) {\n    validator(schema, undefined, { event });\n    return [];\n  }\n  const payload = args.length === 1 ? args[0] : args;\n  const parsed = validator(schema, payload, { event });\n  if (args.length === 1) {\n    return [parsed];\n  }\n  if (!Array.isArray(parsed)) {\n    throw new TypeError(\n      `Schema for event \"${event}\" must return an array/tuple for multi-arg events`,\n    );\n  }\n  return parsed;\n}\n\nfunction splitName(name: string, delimiter: string): string[] {\n  return delimiter ? name.split(delimiter) : [name];\n}\n\nfunction isPatternName(state: EmitterState, name: string): boolean {\n  const wildcard = state.wildcard;\n  if (!wildcard) {\n    return false;\n  }\n  if (name.indexOf(wildcard) === -1) {\n    return false;\n  }\n  const delimiter = state.namespaceDelimiter;\n  const segments = splitName(name, delimiter);\n  return segments.includes(wildcard);\n}\n\n// #4: Single match function for all pattern types (removed prefix fast path)\nfunction matchesPatternSegments(\n  state: EmitterState,\n  entry: PatternEntry,\n  eventSegments: string[],\n): boolean {\n  const wildcard = state.wildcard;\n  const patternSegments = entry.segments;\n  const patternLength = patternSegments.length;\n  const eventLength = eventSegments.length;\n\n  if (entry.trailingWildcard) {\n    if (eventLength < patternLength) {\n      return false;\n    }\n  } else if (eventLength !== patternLength) {\n    return false;\n  }\n\n  const lastIndex = entry.trailingWildcard ? patternLength - 1 : patternLength;\n  for (let i = 0; i < lastIndex; i += 1) {\n    if (\n      patternSegments[i] !== wildcard &&\n      patternSegments[i] !== eventSegments[i]\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction addListener(\n  emitter: object,\n  name: string,\n  callback: CallbackWithOriginal,\n  context?: unknown,\n): void {\n  const state = getState(emitter);\n  const bound = context ?? emitter;\n  const entry: ListenerEntry = { callback, context, bound };\n\n  if (name === \"all\") {\n    state.all.push(entry);\n    return;\n  }\n  // #4: All pattern listeners use the segments path\n  if (isPatternName(state, name)) {\n    const segments = splitName(name, state.namespaceDelimiter);\n    const trailingWildcard = segments[segments.length - 1] === state.wildcard;\n    state.patterns.push({\n      ...entry,\n      pattern: name,\n      segments,\n      trailingWildcard,\n    });\n    return;\n  }\n\n  let list = state.events.get(name);\n  if (!list) {\n    list = [];\n    state.events.set(name, list);\n  }\n  if (!state.dispatchers.has(name)) {\n    const dispatcher: EventListener = (event) => {\n      const args = getEventArgs(event);\n      const snapshot =\n        (event as EventifyCustomEvent)[eventifyListenersKey] ??\n        state.events.get(name) ??\n        [];\n      for (const listenerEntry of snapshot) {\n        safeCall(state, listenerEntry.callback, listenerEntry.bound, args, {\n          event: name,\n          args,\n          listener: listenerEntry.callback,\n          emitter,\n        });\n      }\n    };\n    state.dispatchers.set(name, dispatcher);\n    state.target.addEventListener(name, dispatcher);\n  }\n  list.push(entry);\n}\n\nfunction removeListener(\n  state: EmitterState,\n  name: string,\n  callback?: CallbackWithOriginal | null,\n  context?: unknown,\n): void {\n  const matches = (entry: ListenerEntry): boolean => {\n    const cb = callback as CallbackWithOriginal | null | undefined;\n    const cbMatches =\n      !cb || cb === entry.callback || cb === entry.callback._callback;\n    const ctxMatches = !context || context === entry.context;\n    return cbMatches && ctxMatches;\n  };\n\n  // #8: Use filter instead of manual loop with empty if block\n  if (name === \"all\") {\n    state.all = state.all.filter((e) => !matches(e));\n    return;\n  }\n  if (isPatternName(state, name)) {\n    state.patterns = state.patterns.filter(\n      (e) => e.pattern !== name || !matches(e),\n    );\n    return;\n  }\n\n  const list = state.events.get(name);\n  if (!list) {\n    return;\n  }\n  const retained = list.filter((e) => !matches(e));\n  if (retained.length) {\n    state.events.set(name, retained);\n  } else {\n    state.events.delete(name);\n    const dispatcher = state.dispatchers.get(name);\n    if (dispatcher) {\n      state.target.removeEventListener(name, dispatcher);\n      state.dispatchers.delete(name);\n    }\n  }\n}\n\n// #13: Check whether any listeners on targetState have the given context.\n// Used by stopListening to clean up stale listeningTo references.\nfunction hasListenersWithContext(\n  targetState: EmitterState,\n  context: unknown,\n): boolean {\n  for (const [, list] of targetState.events) {\n    for (const entry of list) {\n      if (entry.context === context) return true;\n    }\n  }\n  for (const entry of targetState.patterns) {\n    if (entry.context === context) return true;\n  }\n  for (const entry of targetState.all) {\n    if (entry.context === context) return true;\n  }\n  return false;\n}\n\n// #7: Shared helper for listenTo and listenToOnce\nfunction listenToHelper(\n  self: AnyEmitter,\n  obj: unknown,\n  name: unknown,\n  callback: unknown,\n  method: \"on\" | \"once\",\n): AnyEmitter {\n  if (!obj) return self;\n  const state = getState(self);\n  state.listeningTo.add(obj as AnyEmitter);\n  const target = obj as AnyEmitter;\n  if (name && typeof name === \"object\") {\n    target[method](name as EventHandlerMap<EventMap>, self);\n  } else {\n    target[method](\n      name as string,\n      callback as CallbackWithOriginal | undefined,\n      self,\n    );\n  }\n  return self;\n}\n\nfunction iterate(\n  this: AnyEmitter,\n  name: \"all\",\n  options?: IterateOptions,\n): AsyncIterableIterator<[EventName<EventMap>, ...unknown[]]>;\nfunction iterate(\n  this: AnyEmitter,\n  name: string,\n  options?: IterateOptions,\n): AsyncIterableIterator<unknown>;\nfunction iterate(\n  this: AnyEmitter,\n  name: string,\n  options?: IterateOptions,\n): AsyncIterableIterator<unknown> {\n  const emitter = this as AnyEmitter;\n  // #14: Queue is unbounded by design. Producers that emit faster than\n  // consumers read will grow this array indefinitely. Use AbortSignal\n  // or return() to bound lifetime.\n  const queue: unknown[] = [];\n  let pending: ((value: IteratorResult<unknown>) => void) | null = null;\n  let done = false;\n  const isAll = name === \"all\";\n\n  const handler = (...args: unknown[]) => {\n    if (done) {\n      return;\n    }\n    const value = isAll ? args : args.length === 1 ? args[0] : args;\n    if (pending) {\n      const resolve = pending;\n      pending = null;\n      resolve({ value, done: false });\n      return;\n    }\n    queue.push(value);\n  };\n\n  emitter.on(name, handler);\n\n  const stop = () => {\n    if (done) {\n      return;\n    }\n    done = true;\n    emitter.off(name, handler);\n    if (pending) {\n      const resolve = pending;\n      pending = null;\n      resolve({ value: undefined, done: true });\n    }\n  };\n\n  if (options?.signal) {\n    if (options.signal.aborted) {\n      stop();\n    } else {\n      options.signal.addEventListener(\"abort\", stop, { once: true });\n    }\n  }\n\n  const iterator: AsyncIterableIterator<unknown> = {\n    [Symbol.asyncIterator]() {\n      return iterator;\n    },\n    next() {\n      if (queue.length) {\n        const value = queue.shift() as unknown;\n        return Promise.resolve({ value, done: false });\n      }\n      if (done) {\n        return Promise.resolve({ value: undefined, done: true });\n      }\n      return new Promise((resolve) => {\n        pending = resolve;\n      });\n    },\n    return() {\n      stop();\n      return Promise.resolve({ value: undefined, done: true });\n    },\n    throw(error) {\n      stop();\n      return Promise.reject(error);\n    },\n  };\n\n  return iterator;\n}\n\nconst proto: EventifyEmitter<EventMap> = {\n  // #5: Simplified — just forward to EventTarget and flag the event name.\n  addEventListener(\n    this: AnyEmitter,\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ) {\n    const state = getState(this);\n    state.target.addEventListener(type, listener, options);\n    if (listener) {\n      state.nativeEvents.add(type);\n    }\n  },\n\n  removeEventListener(\n    this: AnyEmitter,\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | EventListenerOptions,\n  ) {\n    const state = getExistingState(this);\n    if (!state) {\n      return;\n    }\n    state.target.removeEventListener(type, listener, options);\n  },\n\n  dispatchEvent(this: AnyEmitter, event: Event) {\n    const state = getState(this);\n    return state.target.dispatchEvent(event);\n  },\n\n  on(this: AnyEmitter, name: unknown, callback?: unknown, context?: unknown) {\n    if (!eventsApi(this, \"on\", name, [callback, context]) || !callback) {\n      return this;\n    }\n    addListener(\n      this,\n      name as string,\n      callback as CallbackWithOriginal,\n      context,\n    );\n    return this;\n  },\n\n  once(this: AnyEmitter, name: unknown, callback?: unknown, context?: unknown) {\n    if (!eventsApi(this, \"once\", name, [callback, context]) || !callback) {\n      return this;\n    }\n    const self = this as AnyEmitter;\n    let ran = false;\n    const onceListener: CallbackWithOriginal = function (\n      this: unknown,\n      ...args: unknown[]\n    ) {\n      if (ran) {\n        return undefined;\n      }\n      ran = true;\n      self.off(name as string, onceListener, context);\n      return (callback as CallbackWithOriginal).apply(this, args);\n    } as CallbackWithOriginal;\n    onceListener._callback = callback as CallbackWithOriginal;\n    return (this as AnyEmitter).on(name as string, onceListener, context);\n  },\n\n  off(this: AnyEmitter, name?: unknown, callback?: unknown, context?: unknown) {\n    const state = getExistingState(this);\n    if (!state || !eventsApi(this, \"off\", name, [callback, context])) {\n      return this;\n    }\n    if (!name && !callback && !context) {\n      for (const [eventName, dispatcher] of state.dispatchers) {\n        state.target.removeEventListener(eventName, dispatcher);\n      }\n      state.events.clear();\n      state.dispatchers.clear();\n      state.patterns = [];\n      state.all = [];\n      return this;\n    }\n\n    // #9: When name is provided, remove directly. Otherwise iterate each\n    // collection without materializing an intermediate Set from .map().\n    if (name) {\n      removeListener(\n        state,\n        name as string,\n        callback as CallbackWithOriginal,\n        context,\n      );\n    } else {\n      for (const eventName of [...state.events.keys()]) {\n        removeListener(\n          state,\n          eventName,\n          callback as CallbackWithOriginal,\n          context,\n        );\n      }\n      const seenPatterns = new Set<string>();\n      for (const entry of state.patterns) {\n        if (!seenPatterns.has(entry.pattern)) {\n          seenPatterns.add(entry.pattern);\n          removeListener(\n            state,\n            entry.pattern,\n            callback as CallbackWithOriginal,\n            context,\n          );\n        }\n      }\n      if (state.all.length) {\n        removeListener(\n          state,\n          \"all\",\n          callback as CallbackWithOriginal,\n          context,\n        );\n      }\n    }\n    return this;\n  },\n\n  trigger(this: AnyEmitter, name: unknown, ...args: unknown[]) {\n    const state = getExistingState(this);\n    if (!state) {\n      return this;\n    }\n    if (!eventsApi(this, \"trigger\", name, args)) {\n      return this;\n    }\n\n    const eventName = name as string;\n    const validatedArgs = normalizeValidatedArgs(state, eventName, args);\n\n    const eventSnapshot = state.events.get(eventName)?.slice() ?? null;\n    const patternSnapshot = state.patterns.length\n      ? state.patterns.slice()\n      : null;\n    const allSnapshot = state.all.length ? state.all.slice() : null;\n\n    // #5: When native addEventListener listeners exist for this event,\n    // dispatch through EventTarget so both eventify and native listeners fire.\n    // The eventifyListenersKey carries the snapshot for the dispatcher.\n    // Otherwise call eventify listeners directly (avoids CustomEvent overhead).\n    if (state.nativeEvents.has(eventName)) {\n      const event = createEvent(eventName, validatedArgs);\n      if (eventSnapshot?.length) {\n        Object.defineProperty(event, eventifyListenersKey, {\n          value: eventSnapshot,\n          enumerable: false,\n        });\n      }\n      state.target.dispatchEvent(event);\n    } else if (eventSnapshot?.length) {\n      for (const entry of eventSnapshot) {\n        safeCall(state, entry.callback, entry.bound, validatedArgs, {\n          event: eventName,\n          args: validatedArgs,\n          listener: entry.callback,\n          emitter: this,\n        });\n      }\n    }\n\n    if (patternSnapshot) {\n      let eventSegments: string[] | null = null;\n      for (const entry of patternSnapshot) {\n        // #4: Single segments-based match for all patterns\n        if (!eventSegments) {\n          eventSegments = splitName(eventName, state.namespaceDelimiter);\n        }\n        if (!matchesPatternSegments(state, entry, eventSegments)) {\n          continue;\n        }\n        safeCall(state, entry.callback, entry.bound, validatedArgs, {\n          event: eventName,\n          args: validatedArgs,\n          listener: entry.callback,\n          emitter: this,\n        });\n      }\n    }\n\n    if (allSnapshot) {\n      for (const entry of allSnapshot) {\n        safeCall(\n          state,\n          entry.callback,\n          entry.bound,\n          [eventName, ...validatedArgs],\n          {\n            event: eventName,\n            args: validatedArgs,\n            listener: entry.callback,\n            emitter: this,\n          },\n        );\n      }\n    }\n\n    return this;\n  },\n\n  emit(this: AnyEmitter, name: unknown, ...args: unknown[]) {\n    return (this as AnyEmitter).trigger(name as string, ...args);\n  },\n\n  produce(this: AnyEmitter, name: unknown, ...args: unknown[]) {\n    return (this as AnyEmitter).trigger(name as string, ...args);\n  },\n\n  // #7: Deduplicated — both delegate to listenToHelper\n  listenTo(this: AnyEmitter, obj: unknown, name: unknown, callback?: unknown) {\n    return listenToHelper(this, obj, name, callback, \"on\");\n  },\n\n  listenToOnce(\n    this: AnyEmitter,\n    obj: unknown,\n    name: unknown,\n    callback?: unknown,\n  ) {\n    return listenToHelper(this, obj, name, callback, \"once\");\n  },\n\n  stopListening(\n    this: AnyEmitter,\n    obj?: unknown,\n    name?: unknown,\n    callback?: unknown,\n  ) {\n    const state = getExistingState(this);\n    if (!state) {\n      return this;\n    }\n    const removeAll = !name && !callback;\n\n    const targets: AnyEmitter[] = obj\n      ? [obj as AnyEmitter]\n      : [...state.listeningTo.values()];\n\n    for (const target of targets) {\n      if (name && typeof name === \"object\") {\n        target.off(name as EventHandlerMap<EventMap>, this);\n      } else {\n        target.off(\n          name as string | null | undefined,\n          callback as CallbackWithOriginal | null | undefined,\n          this,\n        );\n      }\n      // #13: Clean up stale listeningTo references to allow GC.\n      // For targeted removal, check whether any listeners with our\n      // context remain on the target before keeping the reference.\n      if (!removeAll) {\n        const targetState = getExistingState(target);\n        if (!targetState || !hasListenersWithContext(targetState, this)) {\n          state.listeningTo.delete(target);\n        }\n      }\n    }\n    if (removeAll) {\n      if (obj) {\n        state.listeningTo.delete(obj as AnyEmitter);\n      } else {\n        state.listeningTo.clear();\n      }\n    }\n    return this;\n  },\n\n  iterate,\n};\n\nexport function createEventify<TSchemas extends SchemaMap>(\n  options: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & {\n    schemas: TSchemas;\n  },\n): EventifyEmitter<EventsFromSchemas<TSchemas>>;\nexport function createEventify<\n  TEvents extends EventMap = EventMap,\n  TSchemas extends SchemaMap | undefined = undefined,\n>(options?: EventifyOptions<TSchemas, TEvents>): EventifyEmitter<TEvents>;\nexport function createEventify(\n  options?: EventifyOptions,\n): EventifyEmitter<EventMap> {\n  const emitter = Object.create(proto) as EventifyEmitter<EventMap>;\n  getState(emitter, options as EventifyOptions);\n  return emitter;\n}\n\nexport function enable<TTarget extends object, TSchemas extends SchemaMap>(\n  target: TTarget | undefined,\n  options: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & {\n    schemas: TSchemas;\n  },\n): TTarget & EventifyEmitter<EventsFromSchemas<TSchemas>>;\nexport function enable<\n  TTarget extends object,\n  TEvents extends EventMap = EventMap,\n  TSchemas extends SchemaMap | undefined = undefined,\n>(\n  target?: TTarget,\n  options?: EventifyOptions<TSchemas, TEvents>,\n): TTarget & EventifyEmitter<TEvents>;\n// #11: Copies methods as own enumerable properties for Backbone-style mixin compat.\n// Use createEventify() for prototype-based construction instead.\nexport function enable(\n  target?: object,\n  options?: EventifyOptions,\n): object & EventifyEmitter<EventMap> {\n  const destination = (target ?? {}) as Record<string, unknown>;\n  const protoMethods = proto as unknown as Record<string, unknown>;\n  for (const method of Object.keys(proto)) {\n    destination[method] = protoMethods[method];\n  }\n  getState(destination, options as EventifyOptions);\n  return destination as unknown as object & EventifyEmitter<EventMap>;\n}\n\nconst EventifyInstance = createEventify();\n\n// #10: The default export is both a live emitter and a static namespace\n// for backward compatibility with Eventify v2 / Backbone-style usage.\nconst Eventify = Object.assign(EventifyInstance, {\n  version: \"3.0.0\",\n  enable,\n  create: createEventify,\n  mixin: enable,\n  proto,\n  defaultSchemaValidator,\n}) as EventifyStatic;\n\nconst createEmitter = createEventify;\nconst decorateWithEvents = enable;\n// #2: Compat alias. Prefer importing `defaultSchemaValidator` directly.\nconst setDefaultSchemaValidator = defaultSchemaValidator;\n\nexport {\n  Eventify,\n  createEmitter,\n  decorateWithEvents,\n  setDefaultSchemaValidator,\n};\nexport default Eventify;\n"
  ],
  "mappings": "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",
  "debugId": "977FBEE62A7F036064756E2164756E21",
  "names": []
}