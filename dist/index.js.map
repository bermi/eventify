{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "/* Eventify v3 - type-safe, schema-optional */\n\nexport type EventMap = Record<string, unknown>;\n\nexport type PayloadArgs<T> =\n  [T] extends [void] ? [] :\n  [T] extends [undefined] ? [] :\n  T extends readonly unknown[] ? T :\n  [T];\n\nexport type PayloadValue<T> = T extends readonly unknown[] ? T : T;\n\nexport type EventName<Events extends EventMap> = Extract<keyof Events, string>;\n\nexport type EventHandler<T> = (...args: PayloadArgs<T>) => unknown;\n\nexport type AllHandler<Events extends EventMap> =\n  (event: EventName<Events>, ...args: unknown[]) => unknown;\n\nexport type EventHandlerMap<Events extends EventMap> = {\n  [K in keyof Events]?: EventHandler<Events[K]>;\n};\n\nexport type SchemaLike<T = unknown> =\n  | { parse: (input: unknown) => T }\n  | { safeParse: (input: unknown) => { success: true; data: T } | { success: false; error: unknown } };\n\nexport type SchemaMap = Record<string, SchemaLike>;\n\nexport type InferSchema<S> =\n  S extends { parse: (input: unknown) => infer T } ? T :\n  S extends { safeParse: (input: unknown) => { success: true; data: infer T } } ? T :\n  unknown;\n\nexport type EventsFromSchemas<TSchemas> =\n  TSchemas extends SchemaMap ? { [K in keyof TSchemas]: InferSchema<TSchemas[K]> } : EventMap;\n\nexport type ValidationMeta = { event: string };\n\nexport type SchemaValidator<TSchema extends SchemaLike = SchemaLike> =\n  (schema: TSchema, payload: unknown, meta: ValidationMeta) => unknown;\n\nexport type ErrorMeta<Events extends EventMap> = {\n  event: EventName<Events> | string;\n  args: unknown[];\n  listener?: (...args: unknown[]) => unknown;\n  emitter: object;\n};\n\nexport type ErrorHandler<Events extends EventMap> =\n  (error: unknown, meta: ErrorMeta<Events>) => void;\n\nexport type EventifyOptions<\n  TSchemas extends SchemaMap | undefined = undefined,\n  TEvents extends EventMap = EventMap\n> = {\n  schemas?: TSchemas;\n  validate?: SchemaValidator;\n  onError?: ErrorHandler<TEvents>;\n  namespaceDelimiter?: string;\n  wildcard?: string;\n};\n\nexport type IterateOptions = {\n  signal?: AbortSignal;\n};\n\nexport interface EventifyEmitter<Events extends EventMap = EventMap> {\n  on<K extends EventName<Events>>(\n    name: K,\n    callback: EventHandler<Events[K]>,\n    context?: unknown\n  ): this;\n  on(\n    name: 'all',\n    callback: AllHandler<Events>,\n    context?: unknown\n  ): this;\n  on(\n    name: EventHandlerMap<Events>,\n    context?: unknown\n  ): this;\n  on(\n    name: string,\n    callback?: (...args: unknown[]) => unknown,\n    context?: unknown\n  ): this;\n\n  once<K extends EventName<Events>>(\n    name: K,\n    callback: EventHandler<Events[K]>,\n    context?: unknown\n  ): this;\n  once(\n    name: 'all',\n    callback: AllHandler<Events>,\n    context?: unknown\n  ): this;\n  once(\n    name: EventHandlerMap<Events>,\n    context?: unknown\n  ): this;\n  once(\n    name: string,\n    callback?: (...args: unknown[]) => unknown,\n    context?: unknown\n  ): this;\n\n  off(): this;\n  off<K extends EventName<Events>>(\n    name: K,\n    callback?: EventHandler<Events[K]> | null,\n    context?: unknown\n  ): this;\n  off(\n    name: EventHandlerMap<Events>,\n    context?: unknown\n  ): this;\n  off(\n    name?: string | null,\n    callback?: ((...args: unknown[]) => unknown) | null,\n    context?: unknown\n  ): this;\n\n  trigger<K extends EventName<Events>>(\n    name: K,\n    ...args: PayloadArgs<Events[K]>\n  ): this;\n  trigger(\n    name: string,\n    ...args: unknown[]\n  ): this;\n  emit<K extends EventName<Events>>(\n    name: K,\n    ...args: PayloadArgs<Events[K]>\n  ): this;\n  emit(\n    name: string,\n    ...args: unknown[]\n  ): this;\n  produce<K extends EventName<Events>>(\n    name: K,\n    ...args: PayloadArgs<Events[K]>\n  ): this;\n  produce(\n    name: string,\n    ...args: unknown[]\n  ): this;\n\n  listenTo<OtherEvents extends EventMap, K extends EventName<OtherEvents>>(\n    other: EventifyEmitter<OtherEvents>,\n    name: K,\n    callback: EventHandler<OtherEvents[K]>\n  ): this;\n  listenTo<OtherEvents extends EventMap>(\n    other: EventifyEmitter<OtherEvents>,\n    name: EventHandlerMap<OtherEvents>\n  ): this;\n  listenTo(\n    other: EventifyEmitter<EventMap>,\n    name: string,\n    callback?: (...args: unknown[]) => unknown\n  ): this;\n\n  listenToOnce<OtherEvents extends EventMap, K extends EventName<OtherEvents>>(\n    other: EventifyEmitter<OtherEvents>,\n    name: K,\n    callback: EventHandler<OtherEvents[K]>\n  ): this;\n  listenToOnce<OtherEvents extends EventMap>(\n    other: EventifyEmitter<OtherEvents>,\n    name: EventHandlerMap<OtherEvents>\n  ): this;\n  listenToOnce(\n    other: EventifyEmitter<EventMap>,\n    name: string,\n    callback?: (...args: unknown[]) => unknown\n  ): this;\n\n  stopListening<OtherEvents extends EventMap>(\n    other?: EventifyEmitter<OtherEvents> | null,\n    name?: EventName<OtherEvents> | EventHandlerMap<OtherEvents> | null,\n    callback?: ((...args: unknown[]) => unknown) | null\n  ): this;\n\n  iterate<K extends EventName<Events>>(\n    name: K,\n    options?: IterateOptions\n  ): AsyncIterableIterator<PayloadValue<Events[K]>>;\n  iterate(\n    name: 'all',\n    options?: IterateOptions\n  ): AsyncIterableIterator<[EventName<Events>, ...unknown[]]>;\n  iterate(\n    name: string,\n    options?: IterateOptions\n  ): AsyncIterableIterator<unknown>;\n}\n\nexport interface EventifyStatic<Events extends EventMap = EventMap>\n  extends EventifyEmitter<Events> {\n  version: string;\n  enable<TTarget extends object, TSchemas extends SchemaMap>(\n    target: TTarget | undefined,\n    options: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & { schemas: TSchemas }\n  ): TTarget & EventifyEmitter<EventsFromSchemas<TSchemas>>;\n  enable<TTarget extends object, TEvents extends EventMap = EventMap, TSchemas extends SchemaMap | undefined = undefined>(\n    target?: TTarget,\n    options?: EventifyOptions<TSchemas, TEvents>\n  ): TTarget & EventifyEmitter<TEvents>;\n  create<TSchemas extends SchemaMap>(\n    options: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & { schemas: TSchemas }\n  ): EventifyEmitter<EventsFromSchemas<TSchemas>>;\n  create<TEvents extends EventMap = EventMap, TSchemas extends SchemaMap | undefined = undefined>(\n    options?: EventifyOptions<TSchemas, TEvents>\n  ): EventifyEmitter<TEvents>;\n  mixin: EventifyStatic['enable'];\n  proto: EventifyEmitter<EventMap>;\n  noConflict: () => EventifyStatic<Events>;\n  defaultSchemaValidator: SchemaValidator;\n}\n\ntype AnyCallback = (...args: any[]) => unknown;\ntype AnyEmitter = EventifyEmitter<any>;\n\ntype CallbackWithOriginal = AnyCallback & {\n  _callback?: AnyCallback;\n};\n\ntype ListenerEntry = {\n  callback: CallbackWithOriginal;\n  context?: unknown;\n  ctx: unknown;\n};\n\ntype SegmentPatternEntry = ListenerEntry & {\n  pattern: string;\n  match: 'segments';\n  segments: string[];\n  trailingWildcard: boolean;\n};\n\ntype PrefixPatternEntry = ListenerEntry & {\n  pattern: string;\n  match: 'prefix';\n  prefix: string;\n};\n\ntype PatternEntry = SegmentPatternEntry | PrefixPatternEntry;\n\ntype EmitterState = {\n  events: Map<string, ListenerEntry[]>;\n  patterns: PatternEntry[];\n  all: ListenerEntry[];\n  listeningTo: Set<AnyEmitter>;\n  schemas: SchemaMap | undefined;\n  validate: SchemaValidator | undefined;\n  onError: ErrorHandler<EventMap>;\n  namespaceDelimiter: string;\n  wildcard: string;\n};\n\nconst eventSplitter = /\\s+/;\n\nconst stateByEmitter = new WeakMap<object, EmitterState>();\n\nfunction noop(): void {}\n\nfunction reportError(state: EmitterState, error: unknown, meta: ErrorMeta<EventMap>): void {\n  try {\n    state.onError?.(error, meta);\n  } catch {\n    // Swallow error handler failures to avoid crashes.\n  }\n}\n\nfunction isPromiseLike(value: unknown): value is PromiseLike<unknown> {\n  return typeof value === 'object' && value !== null && typeof (value as PromiseLike<unknown>).then === 'function';\n}\n\nfunction safeCall(\n  state: EmitterState,\n  callback: CallbackWithOriginal,\n  ctx: unknown,\n  args: unknown[],\n  meta: ErrorMeta<EventMap>\n): void {\n  try {\n    const result = callback.apply(ctx, args);\n    if (isPromiseLike(result)) {\n      result.then(undefined, (error: unknown) => reportError(state, error, meta));\n    }\n  } catch (error) {\n    reportError(state, error, meta);\n  }\n}\n\ntype EventApiAction = 'on' | 'once' | 'off' | 'trigger';\ntype EventApiFn = (name: string, ...args: unknown[]) => unknown;\n\nfunction eventsApi(obj: AnyEmitter, action: EventApiAction, name: unknown, rest: unknown[]): boolean {\n  if (!name) {\n    return true;\n  }\n  if (typeof name === 'object') {\n    for (const key in name as Record<string, unknown>) {\n      if (Object.prototype.hasOwnProperty.call(name, key)) {\n        (obj as any)[action](key, (name as Record<string, unknown>)[key], ...rest);\n      }\n    }\n    return false;\n  }\n  if (typeof name === 'string' && eventSplitter.test(name)) {\n    const names = name.split(eventSplitter);\n    for (const eventName of names) {\n      (obj as any)[action](eventName, ...rest);\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function defaultSchemaValidator(\n  schema: SchemaLike,\n  payload: unknown,\n  _meta: ValidationMeta\n): unknown {\n  if (schema && typeof (schema as { parse?: unknown }).parse === 'function') {\n    return (schema as { parse: (input: unknown) => unknown }).parse(payload);\n  }\n  if (schema && typeof (schema as { safeParse?: unknown }).safeParse === 'function') {\n    const result = (schema as { safeParse: (input: unknown) => { success: boolean; data?: unknown; error?: unknown } })\n      .safeParse(payload);\n    if (result && result.success) {\n      return result.data;\n    }\n    throw result?.error ?? new Error('Schema validation failed');\n  }\n  throw new TypeError('Schema validator missing parse/safeParse');\n}\n\nfunction getState(target: object, options?: EventifyOptions): EmitterState {\n  let state = stateByEmitter.get(target);\n  if (!state) {\n    const created: EmitterState = {\n      events: new Map(),\n      patterns: [],\n      all: [],\n      listeningTo: new Set(),\n      schemas: options?.schemas,\n      validate: options?.validate,\n      onError: options?.onError ?? noop,\n      namespaceDelimiter: options?.namespaceDelimiter ?? '/',\n      wildcard: options?.wildcard ?? '*',\n    };\n    if (options?.schemas && !created.validate) {\n      created.validate = defaultSchemaValidator;\n    }\n    stateByEmitter.set(target, created);\n    return created;\n  }\n  if (options) {\n    if (options.schemas) {\n      state.schemas = options.schemas;\n      if (!state.validate) {\n        state.validate = defaultSchemaValidator;\n      }\n    }\n    if (options.validate) {\n      state.validate = options.validate;\n    }\n    if (options.onError) {\n      state.onError = options.onError;\n    }\n    if (options.namespaceDelimiter) {\n      state.namespaceDelimiter = options.namespaceDelimiter;\n    }\n    if (options.wildcard) {\n      state.wildcard = options.wildcard;\n    }\n  }\n  return state;\n}\n\nfunction getExistingState(target: object): EmitterState | undefined {\n  return stateByEmitter.get(target);\n}\n\nfunction normalizeValidatedArgs(\n  state: EmitterState,\n  event: string,\n  args: unknown[]\n): unknown[] {\n  if (!state.schemas) {\n    return args;\n  }\n  const schema = state.schemas[event];\n  if (!schema) {\n    return args;\n  }\n  const validator = state.validate ?? defaultSchemaValidator;\n  if (args.length === 0) {\n    validator(schema, undefined, { event });\n    return [];\n  }\n  const payload = args.length === 1 ? args[0] : args;\n  const parsed = validator(schema, payload, { event });\n  if (args.length === 1) {\n    return [parsed];\n  }\n  if (!Array.isArray(parsed)) {\n    throw new TypeError(`Schema for event \"${event}\" must return an array/tuple for multi-arg events`);\n  }\n  return parsed;\n}\n\nfunction splitName(name: string, delimiter: string): string[] {\n  return delimiter ? name.split(delimiter) : [name];\n}\n\nfunction isPatternName(state: EmitterState, name: string): boolean {\n  const wildcard = state.wildcard;\n  if (!wildcard) {\n    return false;\n  }\n  if (name.indexOf(wildcard) === -1) {\n    return false;\n  }\n  const delimiter = state.namespaceDelimiter;\n  const segments = splitName(name, delimiter);\n  return segments.includes(wildcard);\n}\n\nfunction matchesPatternSegments(state: EmitterState, entry: SegmentPatternEntry, eventSegments: string[]): boolean {\n  const wildcard = state.wildcard;\n  const patternSegments = entry.segments;\n  const patternLength = patternSegments.length;\n  const eventLength = eventSegments.length;\n\n  if (entry.trailingWildcard) {\n    if (eventLength < patternLength) {\n      return false;\n    }\n  } else if (eventLength !== patternLength) {\n    return false;\n  }\n\n  const lastIndex = entry.trailingWildcard ? patternLength - 1 : patternLength;\n  for (let i = 0; i < lastIndex; i += 1) {\n    const segment = patternSegments[i];\n    if (segment === wildcard) {\n      continue;\n    }\n    if (segment !== eventSegments[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction addListener(\n  emitter: object,\n  name: string,\n  callback: CallbackWithOriginal,\n  context?: unknown\n): void {\n  const state = getState(emitter);\n  const ctx = context ?? emitter;\n  const entry: ListenerEntry = {\n    callback,\n    context,\n    ctx,\n  };\n\n  if (name === 'all') {\n    state.all.push(entry);\n    return;\n  }\n  if (isPatternName(state, name)) {\n    const segments = splitName(name, state.namespaceDelimiter);\n    const trailingWildcard = segments[segments.length - 1] === state.wildcard;\n    const hasInternalWildcard = segments.slice(0, -1).includes(state.wildcard);\n    if (trailingWildcard && !hasInternalWildcard) {\n      state.patterns.push({\n        ...entry,\n        pattern: name,\n        match: 'prefix',\n        prefix: name.slice(0, Math.max(0, name.length - state.wildcard.length)),\n      });\n    } else {\n      state.patterns.push({\n        ...entry,\n        pattern: name,\n        match: 'segments',\n        segments,\n        trailingWildcard,\n      });\n    }\n    return;\n  }\n\n  const list = state.events.get(name);\n  if (list) {\n    list.push(entry);\n  } else {\n    state.events.set(name, [entry]);\n  }\n}\n\nfunction removeListener(\n  state: EmitterState,\n  name: string,\n  callback?: CallbackWithOriginal | null,\n  context?: unknown\n): void {\n  const matches = (entry: ListenerEntry): boolean => {\n    const cb = callback as CallbackWithOriginal | null | undefined;\n    const cbMatches = !cb || cb === entry.callback || cb === entry.callback._callback;\n    const ctxMatches = !context || context === entry.context;\n    return cbMatches && ctxMatches;\n  };\n\n  const removeFromList = (list: ListenerEntry[]): ListenerEntry[] => {\n    const retained: ListenerEntry[] = [];\n    for (const entry of list) {\n      if (matches(entry)) {\n      } else {\n        retained.push(entry);\n      }\n    }\n    return retained;\n  };\n\n  if (name === 'all') {\n    state.all = removeFromList(state.all);\n    return;\n  }\n  if (isPatternName(state, name)) {\n    const retained: PatternEntry[] = [];\n    for (const entry of state.patterns) {\n      if (entry.pattern !== name || !matches(entry)) {\n        retained.push(entry);\n      }\n    }\n    state.patterns = retained;\n    return;\n  }\n\n  const list = state.events.get(name);\n  if (!list) {\n    return;\n  }\n  const retained = removeFromList(list);\n  if (retained.length) {\n    state.events.set(name, retained);\n  } else {\n    state.events.delete(name);\n  }\n}\n\nconst proto: EventifyEmitter<any> = {\n  on(this: AnyEmitter, name: any, callback?: any, context?: unknown) {\n    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) {\n      return this;\n    }\n    addListener(this, name as string, callback as CallbackWithOriginal, context);\n    return this;\n  },\n\n  once(this: AnyEmitter, name: any, callback?: any, context?: unknown) {\n    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) {\n      return this;\n    }\n    const self = this as AnyEmitter;\n    let ran = false;\n    const onceListener: CallbackWithOriginal = function (this: unknown, ...args: unknown[]) {\n      if (ran) {\n        return undefined;\n      }\n      ran = true;\n      self.off(name, onceListener, context);\n      return (callback as CallbackWithOriginal).apply(this, args);\n    } as CallbackWithOriginal;\n    onceListener._callback = callback as CallbackWithOriginal;\n    return (this as AnyEmitter).on(name, onceListener, context);\n  },\n\n  off(this: AnyEmitter, name?: any, callback?: any, context?: unknown) {\n    const state = getExistingState(this);\n    if (!state || !eventsApi(this, 'off', name, [callback, context])) {\n      return this;\n    }\n    if (!name && !callback && !context) {\n      state.events.clear();\n      state.patterns = [];\n      state.all = [];\n      return this;\n    }\n\n    const patternNames = new Set(state.patterns.map((entry) => entry.pattern));\n    const names = name ? [name as string] : [\n      ...state.events.keys(),\n      ...patternNames,\n      ...(state.all.length ? ['all'] : []),\n    ];\n\n    for (const eventName of names) {\n      removeListener(state, eventName, callback as CallbackWithOriginal, context);\n    }\n    return this;\n  },\n\n  trigger(this: AnyEmitter, name: any, ...args: unknown[]) {\n    const state = getExistingState(this);\n    if (!state) {\n      return this;\n    }\n    if (!eventsApi(this, 'trigger', name, args)) {\n      return this;\n    }\n\n    const eventName = name as string;\n    const validatedArgs = normalizeValidatedArgs(state, eventName, args);\n\n    const eventSnapshot = state.events.get(eventName)?.slice() ?? null;\n    const patternSnapshot = state.patterns.length ? state.patterns.slice() : null;\n    const allSnapshot = state.all.length ? state.all.slice() : null;\n    let eventSegments: string[] | null = null;\n\n    if (eventSnapshot) {\n      for (const entry of eventSnapshot) {\n        safeCall(state, entry.callback, entry.ctx, validatedArgs, {\n          event: eventName,\n          args: validatedArgs,\n          listener: entry.callback,\n          emitter: this,\n        });\n      }\n    }\n\n    if (patternSnapshot) {\n      for (const entry of patternSnapshot) {\n        if (entry.match === 'prefix') {\n          if (!eventName.startsWith(entry.prefix)) {\n            continue;\n          }\n        } else {\n          if (!eventSegments) {\n            eventSegments = splitName(eventName, state.namespaceDelimiter);\n          }\n          if (!matchesPatternSegments(state, entry, eventSegments)) {\n            continue;\n          }\n        }\n        safeCall(state, entry.callback, entry.ctx, validatedArgs, {\n          event: eventName,\n          args: validatedArgs,\n          listener: entry.callback,\n          emitter: this,\n        });\n      }\n    }\n\n    if (allSnapshot) {\n      for (const entry of allSnapshot) {\n        safeCall(state, entry.callback, entry.ctx, [eventName, ...validatedArgs], {\n          event: eventName,\n          args: validatedArgs,\n          listener: entry.callback,\n          emitter: this,\n        });\n      }\n    }\n\n    return this;\n  },\n\n  emit(this: AnyEmitter, name: any, ...args: unknown[]) {\n    return (this as AnyEmitter).trigger(name, ...args);\n  },\n\n  produce(this: AnyEmitter, name: any, ...args: unknown[]) {\n    return (this as AnyEmitter).trigger(name, ...args);\n  },\n\n  listenTo(this: AnyEmitter, obj: any, name: any, callback?: any) {\n    if (!obj) {\n      return this;\n    }\n    const state = getState(this);\n    state.listeningTo.add(obj as AnyEmitter);\n    if (typeof name === 'object') {\n      callback = this;\n    }\n    (obj as AnyEmitter).on(name, callback, this);\n    return this;\n  },\n\n  listenToOnce(this: AnyEmitter, obj: any, name: any, callback?: any) {\n    if (!obj) {\n      return this;\n    }\n    const state = getState(this);\n    state.listeningTo.add(obj as AnyEmitter);\n    if (typeof name === 'object') {\n      callback = this;\n    }\n    (obj as AnyEmitter).once(name, callback, this);\n    return this;\n  },\n\n  stopListening(this: AnyEmitter, obj?: any, name?: any, callback?: any) {\n    const state = getExistingState(this);\n    if (!state) {\n      return this;\n    }\n    const deleteListener = !name && !callback;\n    if (typeof name === 'object') {\n      callback = this;\n    }\n\n    const targets: AnyEmitter[] = [];\n    if (obj) {\n      targets.push(obj as AnyEmitter);\n    } else {\n      targets.push(...state.listeningTo.values());\n    }\n\n    for (const target of targets) {\n      (target as AnyEmitter).off(name, callback, this);\n      if (deleteListener) {\n        state.listeningTo.delete(target);\n      }\n    }\n    if (deleteListener && !obj) {\n      state.listeningTo.clear();\n    }\n    return this;\n  },\n\n  iterate(this: AnyEmitter, name: any, options?: IterateOptions): AsyncIterableIterator<any> {\n    const emitter = this as AnyEmitter;\n    const queue: unknown[] = [];\n    let pending: ((value: IteratorResult<unknown>) => void) | null = null;\n    let done = false;\n    const isAll = name === 'all';\n\n    const handler = (...args: unknown[]) => {\n      if (done) {\n        return;\n      }\n      const value = isAll ? args : (args.length === 1 ? args[0] : args);\n      if (pending) {\n        const resolve = pending;\n        pending = null;\n        resolve({ value, done: false });\n        return;\n      }\n      queue.push(value);\n    };\n\n    emitter.on(name, handler);\n\n    const stop = () => {\n      if (done) {\n        return;\n      }\n      done = true;\n      emitter.off(name, handler);\n      if (pending) {\n        const resolve = pending;\n        pending = null;\n        resolve({ value: undefined, done: true });\n      }\n    };\n\n    if (options?.signal) {\n      if (options.signal.aborted) {\n        stop();\n      } else {\n        options.signal.addEventListener('abort', stop, { once: true });\n      }\n    }\n\n    const iterator: AsyncIterableIterator<any> = {\n      [Symbol.asyncIterator]() {\n        return iterator;\n      },\n      next() {\n        if (queue.length) {\n          const value = queue.shift() as unknown;\n          return Promise.resolve({ value, done: false });\n        }\n        if (done) {\n          return Promise.resolve({ value: undefined, done: true });\n        }\n        return new Promise((resolve) => {\n          pending = resolve;\n        });\n      },\n      return() {\n        stop();\n        return Promise.resolve({ value: undefined, done: true });\n      },\n      throw(error) {\n        stop();\n        return Promise.reject(error);\n      },\n    };\n\n    return iterator;\n  },\n};\n\nexport function createEventify<TSchemas extends SchemaMap>(\n  options: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & { schemas: TSchemas }\n): EventifyEmitter<EventsFromSchemas<TSchemas>>;\nexport function createEventify<TEvents extends EventMap = EventMap, TSchemas extends SchemaMap | undefined = undefined>(\n  options?: EventifyOptions<TSchemas, TEvents>\n): EventifyEmitter<TEvents>;\nexport function createEventify(\n  options?: EventifyOptions\n): EventifyEmitter<EventMap> {\n  const emitter = Object.create(proto) as EventifyEmitter<EventMap>;\n  getState(emitter, options as EventifyOptions);\n  return emitter;\n}\n\nexport function enable<TTarget extends object, TSchemas extends SchemaMap>(\n  target: TTarget | undefined,\n  options: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & { schemas: TSchemas }\n): TTarget & EventifyEmitter<EventsFromSchemas<TSchemas>>;\nexport function enable<TTarget extends object, TEvents extends EventMap = EventMap, TSchemas extends SchemaMap | undefined = undefined>(\n  target?: TTarget,\n  options?: EventifyOptions<TSchemas, TEvents>\n): TTarget & EventifyEmitter<TEvents>;\nexport function enable(\n  target?: object,\n  options?: EventifyOptions\n): object & EventifyEmitter<EventMap> {\n  const destination = (target ?? {}) as Record<string, unknown>;\n  for (const method of Object.keys(proto)) {\n    (destination as any)[method] = (proto as any)[method];\n  }\n  getState(destination, options as EventifyOptions);\n  return destination as unknown as object & EventifyEmitter<EventMap>;\n}\n\nconst EventifyInstance = createEventify();\n\nconst Eventify = Object.assign(EventifyInstance, {\n  version: '3.0.0',\n  enable,\n  create: createEventify,\n  mixin: enable,\n  proto,\n  noConflict: () => Eventify as EventifyStatic,\n  defaultSchemaValidator,\n}) as EventifyStatic;\n\nconst createEmitter = createEventify;\nconst decorateWithEvents = enable;\nconst setDefaultSchemaValidator = defaultSchemaValidator;\n\nexport { Eventify, createEmitter, decorateWithEvents, setDefaultSchemaValidator };\nexport default Eventify;\n"
  ],
  "mappings": "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",
  "debugId": "9E2160D6D493EC8764756E2164756E21",
  "names": []
}