{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "/* Eventify v3 - type-safe, schema-optional */\n\nexport type EventMap = Record<string, unknown>;\n\nexport type PayloadArgs<T> = [T] extends [void]\n\t? []\n\t: [T] extends [undefined]\n\t\t? []\n\t\t: T extends readonly unknown[]\n\t\t\t? T\n\t\t\t: [T];\n\nexport type PayloadValue<T> = T extends readonly unknown[] ? T : T;\n\nexport type EventName<Events extends EventMap> = Extract<keyof Events, string>;\n\nexport type EventHandler<T> = (...args: PayloadArgs<T>) => unknown;\n\nexport type AllHandler<Events extends EventMap> = (\n\tevent: EventName<Events>,\n\t...args: unknown[]\n) => unknown;\n\nexport type EventHandlerMap<Events extends EventMap> = {\n\t[K in keyof Events]?: EventHandler<Events[K]>;\n};\n\nexport type SchemaLike<T = unknown> =\n\t| { parse: (input: unknown) => T }\n\t| {\n\t\t\tsafeParse: (\n\t\t\t\tinput: unknown,\n\t\t\t) => { success: true; data: T } | { success: false; error: unknown };\n\t  };\n\nexport type SchemaMap = Record<string, SchemaLike>;\n\nexport type InferSchema<S> = S extends { parse: (input: unknown) => infer T }\n\t? T\n\t: S extends {\n\t\t\t\tsafeParse: (input: unknown) => { success: true; data: infer T };\n\t\t\t}\n\t\t? T\n\t\t: unknown;\n\nexport type EventsFromSchemas<TSchemas> = TSchemas extends SchemaMap\n\t? { [K in keyof TSchemas]: InferSchema<TSchemas[K]> }\n\t: EventMap;\n\nexport type ValidationMeta = { event: string };\n\nexport type SchemaValidator<TSchema extends SchemaLike = SchemaLike> = (\n\tschema: TSchema,\n\tpayload: unknown,\n\tmeta: ValidationMeta,\n) => unknown;\n\nexport type ErrorMeta<Events extends EventMap> = {\n\tevent: EventName<Events> | string;\n\targs: unknown[];\n\tlistener?: (...args: unknown[]) => unknown;\n\temitter: object;\n};\n\nexport type ErrorHandler<Events extends EventMap> = (\n\terror: unknown,\n\tmeta: ErrorMeta<Events>,\n) => void;\n\nexport type EventifyOptions<\n\tTSchemas extends SchemaMap | undefined = undefined,\n\tTEvents extends EventMap = EventMap,\n> = {\n\tschemas?: TSchemas;\n\tvalidate?: SchemaValidator;\n\tonError?: ErrorHandler<TEvents>;\n\tnamespaceDelimiter?: string;\n\twildcard?: string;\n};\n\nexport type IterateOptions = {\n\tsignal?: AbortSignal;\n};\n\nexport interface EventifyEmitter<Events extends EventMap = EventMap> {\n\taddEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject | null,\n\t\toptions?: boolean | AddEventListenerOptions,\n\t): void;\n\tremoveEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject | null,\n\t\toptions?: boolean | EventListenerOptions,\n\t): void;\n\tdispatchEvent(event: Event): boolean;\n\n\ton<K extends EventName<Events>>(\n\t\tname: K,\n\t\tcallback: EventHandler<Events[K]>,\n\t\tcontext?: unknown,\n\t): this;\n\ton(name: \"all\", callback: AllHandler<Events>, context?: unknown): this;\n\ton(name: EventHandlerMap<Events>, context?: unknown): this;\n\ton(\n\t\tname: string,\n\t\tcallback?: (...args: unknown[]) => unknown,\n\t\tcontext?: unknown,\n\t): this;\n\n\tonce<K extends EventName<Events>>(\n\t\tname: K,\n\t\tcallback: EventHandler<Events[K]>,\n\t\tcontext?: unknown,\n\t): this;\n\tonce(name: \"all\", callback: AllHandler<Events>, context?: unknown): this;\n\tonce(name: EventHandlerMap<Events>, context?: unknown): this;\n\tonce(\n\t\tname: string,\n\t\tcallback?: (...args: unknown[]) => unknown,\n\t\tcontext?: unknown,\n\t): this;\n\n\toff(): this;\n\toff<K extends EventName<Events>>(\n\t\tname: K,\n\t\tcallback?: EventHandler<Events[K]> | null,\n\t\tcontext?: unknown,\n\t): this;\n\toff(name: EventHandlerMap<Events>, context?: unknown): this;\n\toff(\n\t\tname?: string | null,\n\t\tcallback?: ((...args: unknown[]) => unknown) | null,\n\t\tcontext?: unknown,\n\t): this;\n\n\ttrigger<K extends EventName<Events>>(\n\t\tname: K,\n\t\t...args: PayloadArgs<Events[K]>\n\t): this;\n\ttrigger(name: string, ...args: unknown[]): this;\n\temit<K extends EventName<Events>>(\n\t\tname: K,\n\t\t...args: PayloadArgs<Events[K]>\n\t): this;\n\temit(name: string, ...args: unknown[]): this;\n\tproduce<K extends EventName<Events>>(\n\t\tname: K,\n\t\t...args: PayloadArgs<Events[K]>\n\t): this;\n\tproduce(name: string, ...args: unknown[]): this;\n\n\tlistenTo<OtherEvents extends EventMap, K extends EventName<OtherEvents>>(\n\t\tother: EventifyEmitter<OtherEvents>,\n\t\tname: K,\n\t\tcallback: EventHandler<OtherEvents[K]>,\n\t): this;\n\tlistenTo<OtherEvents extends EventMap>(\n\t\tother: EventifyEmitter<OtherEvents>,\n\t\tname: EventHandlerMap<OtherEvents>,\n\t): this;\n\tlistenTo(\n\t\tother: EventifyEmitter<EventMap>,\n\t\tname: string,\n\t\tcallback?: (...args: unknown[]) => unknown,\n\t): this;\n\n\tlistenToOnce<OtherEvents extends EventMap, K extends EventName<OtherEvents>>(\n\t\tother: EventifyEmitter<OtherEvents>,\n\t\tname: K,\n\t\tcallback: EventHandler<OtherEvents[K]>,\n\t): this;\n\tlistenToOnce<OtherEvents extends EventMap>(\n\t\tother: EventifyEmitter<OtherEvents>,\n\t\tname: EventHandlerMap<OtherEvents>,\n\t): this;\n\tlistenToOnce(\n\t\tother: EventifyEmitter<EventMap>,\n\t\tname: string,\n\t\tcallback?: (...args: unknown[]) => unknown,\n\t): this;\n\n\tstopListening<OtherEvents extends EventMap>(\n\t\tother?: EventifyEmitter<OtherEvents> | null,\n\t\tname?: EventName<OtherEvents> | EventHandlerMap<OtherEvents> | null,\n\t\tcallback?: ((...args: unknown[]) => unknown) | null,\n\t): this;\n\n\titerate<K extends EventName<Events>>(\n\t\tname: K,\n\t\toptions?: IterateOptions,\n\t): AsyncIterableIterator<PayloadValue<Events[K]>>;\n\titerate(\n\t\tname: \"all\",\n\t\toptions?: IterateOptions,\n\t): AsyncIterableIterator<[EventName<Events>, ...unknown[]]>;\n\titerate(\n\t\tname: string,\n\t\toptions?: IterateOptions,\n\t): AsyncIterableIterator<unknown>;\n}\n\nexport interface EventifyStatic<Events extends EventMap = EventMap>\n\textends EventifyEmitter<Events> {\n\tversion: string;\n\tenable<TTarget extends object, TSchemas extends SchemaMap>(\n\t\ttarget: TTarget | undefined,\n\t\toptions: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & {\n\t\t\tschemas: TSchemas;\n\t\t},\n\t): TTarget & EventifyEmitter<EventsFromSchemas<TSchemas>>;\n\tenable<\n\t\tTTarget extends object,\n\t\tTEvents extends EventMap = EventMap,\n\t\tTSchemas extends SchemaMap | undefined = undefined,\n\t>(\n\t\ttarget?: TTarget,\n\t\toptions?: EventifyOptions<TSchemas, TEvents>,\n\t): TTarget & EventifyEmitter<TEvents>;\n\tcreate<TSchemas extends SchemaMap>(\n\t\toptions: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & {\n\t\t\tschemas: TSchemas;\n\t\t},\n\t): EventifyEmitter<EventsFromSchemas<TSchemas>>;\n\tcreate<\n\t\tTEvents extends EventMap = EventMap,\n\t\tTSchemas extends SchemaMap | undefined = undefined,\n\t>(options?: EventifyOptions<TSchemas, TEvents>): EventifyEmitter<TEvents>;\n\tmixin: EventifyStatic[\"enable\"];\n\tproto: EventifyEmitter<EventMap>;\n\tnoConflict: () => EventifyStatic<Events>;\n\tdefaultSchemaValidator: SchemaValidator;\n}\n\ntype AnyCallback = (...args: unknown[]) => unknown;\ntype AnyEmitter = EventifyEmitter<EventMap>;\n\ntype CallbackWithOriginal = AnyCallback & {\n\t_callback?: AnyCallback;\n};\n\ntype ListenerEntry = {\n\tcallback: CallbackWithOriginal;\n\tcontext?: unknown;\n\tctx: unknown;\n};\n\ntype SegmentPatternEntry = ListenerEntry & {\n\tpattern: string;\n\tmatch: \"segments\";\n\tsegments: string[];\n\ttrailingWildcard: boolean;\n};\n\ntype PrefixPatternEntry = ListenerEntry & {\n\tpattern: string;\n\tmatch: \"prefix\";\n\tprefix: string;\n};\n\ntype PatternEntry = SegmentPatternEntry | PrefixPatternEntry;\n\ntype EmitterState = {\n\tevents: Map<string, ListenerEntry[]>;\n\tpatterns: PatternEntry[];\n\tall: ListenerEntry[];\n\tlisteningTo: Set<AnyEmitter>;\n\ttarget: EventTarget;\n\tdispatchers: Map<string, EventListener>;\n\tnativeListeners: Map<string, Set<EventListenerOrEventListenerObject>>;\n\tschemas: SchemaMap | undefined;\n\tvalidate: SchemaValidator | undefined;\n\tonError: ErrorHandler<EventMap>;\n\tnamespaceDelimiter: string;\n\twildcard: string;\n};\n\nconst eventSplitter = /\\s+/;\nconst eventifyArgsKey: unique symbol = Symbol(\"eventifyArgs\");\nconst eventifyListenersKey: unique symbol = Symbol(\"eventifyListeners\");\n\ntype EventifyCustomEvent = CustomEvent<unknown> & {\n\t[eventifyArgsKey]?: unknown[];\n\t[eventifyListenersKey]?: ListenerEntry[];\n};\n\nconst stateByEmitter = new WeakMap<object, EmitterState>();\n\nfunction noop(): void {}\n\nfunction reportError(\n\tstate: EmitterState,\n\terror: unknown,\n\tmeta: ErrorMeta<EventMap>,\n): void {\n\ttry {\n\t\tstate.onError?.(error, meta);\n\t} catch {\n\t\t// Swallow error handler failures to avoid crashes.\n\t}\n}\n\nfunction isPromiseLike(value: unknown): value is PromiseLike<unknown> {\n\treturn (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\ttypeof (value as PromiseLike<unknown>).then === \"function\"\n\t);\n}\n\nfunction safeCall(\n\tstate: EmitterState,\n\tcallback: CallbackWithOriginal,\n\tctx: unknown,\n\targs: unknown[],\n\tmeta: ErrorMeta<EventMap>,\n): void {\n\ttry {\n\t\tconst result = callback.apply(ctx, args);\n\t\tif (isPromiseLike(result)) {\n\t\t\tresult.then(undefined, (error: unknown) =>\n\t\t\t\treportError(state, error, meta),\n\t\t\t);\n\t\t}\n\t} catch (error) {\n\t\treportError(state, error, meta);\n\t}\n}\n\nfunction getEventArgs(event: Event): unknown[] {\n\tconst customEvent = event as EventifyCustomEvent;\n\tconst stored = customEvent[eventifyArgsKey];\n\tif (stored) {\n\t\treturn stored;\n\t}\n\tif (\"detail\" in customEvent) {\n\t\tconst detail = (customEvent as CustomEvent<unknown>).detail;\n\t\tif (detail === undefined) {\n\t\t\treturn [];\n\t\t}\n\t\treturn Array.isArray(detail) ? detail : [detail];\n\t}\n\treturn [];\n}\n\nfunction createEvent(name: string, args: unknown[]): CustomEvent<unknown> {\n\tconst detail = args.length <= 1 ? args[0] : args;\n\tconst event = new CustomEvent(name, { detail }) as EventifyCustomEvent;\n\tObject.defineProperty(event, eventifyArgsKey, {\n\t\tvalue: args,\n\t\tenumerable: false,\n\t});\n\treturn event;\n}\n\ntype EventApiAction = \"on\" | \"once\" | \"off\" | \"trigger\";\nfunction eventsApi(\n\tobj: AnyEmitter,\n\taction: EventApiAction,\n\tname: unknown,\n\trest: unknown[],\n): boolean {\n\tif (!name) {\n\t\treturn true;\n\t}\n\tconst target = obj as EventifyEmitter<EventMap>;\n\tconst method = target[action] as (...args: unknown[]) => unknown;\n\tif (typeof name === \"object\") {\n\t\tfor (const key in name as Record<string, unknown>) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(name, key)) {\n\t\t\t\tmethod.call(\n\t\t\t\t\ttarget,\n\t\t\t\t\tkey,\n\t\t\t\t\t(name as Record<string, unknown>)[key],\n\t\t\t\t\t...rest,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tif (typeof name === \"string\" && eventSplitter.test(name)) {\n\t\tconst names = name.split(eventSplitter);\n\t\tfor (const eventName of names) {\n\t\t\tmethod.call(target, eventName, ...rest);\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nexport function defaultSchemaValidator(\n\tschema: SchemaLike,\n\tpayload: unknown,\n\t_meta: ValidationMeta,\n): unknown {\n\tif (schema && typeof (schema as { parse?: unknown }).parse === \"function\") {\n\t\treturn (schema as { parse: (input: unknown) => unknown }).parse(payload);\n\t}\n\tif (\n\t\tschema &&\n\t\ttypeof (schema as { safeParse?: unknown }).safeParse === \"function\"\n\t) {\n\t\tconst result = (\n\t\t\tschema as {\n\t\t\t\tsafeParse: (input: unknown) => {\n\t\t\t\t\tsuccess: boolean;\n\t\t\t\t\tdata?: unknown;\n\t\t\t\t\terror?: unknown;\n\t\t\t\t};\n\t\t\t}\n\t\t).safeParse(payload);\n\t\tif (result && result.success) {\n\t\t\treturn result.data;\n\t\t}\n\t\tthrow result?.error ?? new Error(\"Schema validation failed\");\n\t}\n\tthrow new TypeError(\"Schema validator missing parse/safeParse\");\n}\n\nfunction getState(target: object, options?: EventifyOptions): EmitterState {\n\tlet state = stateByEmitter.get(target);\n\tif (!state) {\n\t\tconst created: EmitterState = {\n\t\t\tevents: new Map(),\n\t\t\tpatterns: [],\n\t\t\tall: [],\n\t\t\tlisteningTo: new Set(),\n\t\t\ttarget: new EventTarget(),\n\t\t\tdispatchers: new Map(),\n\t\t\tnativeListeners: new Map(),\n\t\t\tschemas: options?.schemas,\n\t\t\tvalidate: options?.validate,\n\t\t\tonError: options?.onError ?? noop,\n\t\t\tnamespaceDelimiter: options?.namespaceDelimiter ?? \"/\",\n\t\t\twildcard: options?.wildcard ?? \"*\",\n\t\t};\n\t\tif (options?.schemas && !created.validate) {\n\t\t\tcreated.validate = defaultSchemaValidator;\n\t\t}\n\t\tstateByEmitter.set(target, created);\n\t\treturn created;\n\t}\n\tif (options) {\n\t\tif (options.schemas) {\n\t\t\tstate.schemas = options.schemas;\n\t\t\tif (!state.validate) {\n\t\t\t\tstate.validate = defaultSchemaValidator;\n\t\t\t}\n\t\t}\n\t\tif (options.validate) {\n\t\t\tstate.validate = options.validate;\n\t\t}\n\t\tif (options.onError) {\n\t\t\tstate.onError = options.onError;\n\t\t}\n\t\tif (options.namespaceDelimiter) {\n\t\t\tstate.namespaceDelimiter = options.namespaceDelimiter;\n\t\t}\n\t\tif (options.wildcard) {\n\t\t\tstate.wildcard = options.wildcard;\n\t\t}\n\t}\n\treturn state;\n}\n\nfunction getExistingState(target: object): EmitterState | undefined {\n\treturn stateByEmitter.get(target);\n}\n\nfunction normalizeValidatedArgs(\n\tstate: EmitterState,\n\tevent: string,\n\targs: unknown[],\n): unknown[] {\n\tif (!state.schemas) {\n\t\treturn args;\n\t}\n\tconst schema = state.schemas[event];\n\tif (!schema) {\n\t\treturn args;\n\t}\n\tconst validator = state.validate ?? defaultSchemaValidator;\n\tif (args.length === 0) {\n\t\tvalidator(schema, undefined, { event });\n\t\treturn [];\n\t}\n\tconst payload = args.length === 1 ? args[0] : args;\n\tconst parsed = validator(schema, payload, { event });\n\tif (args.length === 1) {\n\t\treturn [parsed];\n\t}\n\tif (!Array.isArray(parsed)) {\n\t\tthrow new TypeError(\n\t\t\t`Schema for event \"${event}\" must return an array/tuple for multi-arg events`,\n\t\t);\n\t}\n\treturn parsed;\n}\n\nfunction splitName(name: string, delimiter: string): string[] {\n\treturn delimiter ? name.split(delimiter) : [name];\n}\n\nfunction isPatternName(state: EmitterState, name: string): boolean {\n\tconst wildcard = state.wildcard;\n\tif (!wildcard) {\n\t\treturn false;\n\t}\n\tif (name.indexOf(wildcard) === -1) {\n\t\treturn false;\n\t}\n\tconst delimiter = state.namespaceDelimiter;\n\tconst segments = splitName(name, delimiter);\n\treturn segments.includes(wildcard);\n}\n\nfunction matchesPatternSegments(\n\tstate: EmitterState,\n\tentry: SegmentPatternEntry,\n\teventSegments: string[],\n): boolean {\n\tconst wildcard = state.wildcard;\n\tconst patternSegments = entry.segments;\n\tconst patternLength = patternSegments.length;\n\tconst eventLength = eventSegments.length;\n\n\tif (entry.trailingWildcard) {\n\t\tif (eventLength < patternLength) {\n\t\t\treturn false;\n\t\t}\n\t} else if (eventLength !== patternLength) {\n\t\treturn false;\n\t}\n\n\tconst lastIndex = entry.trailingWildcard ? patternLength - 1 : patternLength;\n\tfor (let i = 0; i < lastIndex; i += 1) {\n\t\tconst segment = patternSegments[i];\n\t\tif (segment === wildcard) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (segment !== eventSegments[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction addListener(\n\temitter: object,\n\tname: string,\n\tcallback: CallbackWithOriginal,\n\tcontext?: unknown,\n): void {\n\tconst state = getState(emitter);\n\tconst ctx = context ?? emitter;\n\tconst entry: ListenerEntry = {\n\t\tcallback,\n\t\tcontext,\n\t\tctx,\n\t};\n\n\tif (name === \"all\") {\n\t\tstate.all.push(entry);\n\t\treturn;\n\t}\n\tif (isPatternName(state, name)) {\n\t\tconst segments = splitName(name, state.namespaceDelimiter);\n\t\tconst trailingWildcard = segments[segments.length - 1] === state.wildcard;\n\t\tconst hasInternalWildcard = segments.slice(0, -1).includes(state.wildcard);\n\t\tif (trailingWildcard && !hasInternalWildcard) {\n\t\t\tstate.patterns.push({\n\t\t\t\t...entry,\n\t\t\t\tpattern: name,\n\t\t\t\tmatch: \"prefix\",\n\t\t\t\tprefix: name.slice(0, Math.max(0, name.length - state.wildcard.length)),\n\t\t\t});\n\t\t} else {\n\t\t\tstate.patterns.push({\n\t\t\t\t...entry,\n\t\t\t\tpattern: name,\n\t\t\t\tmatch: \"segments\",\n\t\t\t\tsegments,\n\t\t\t\ttrailingWildcard,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tlet list = state.events.get(name);\n\tif (!list) {\n\t\tlist = [];\n\t\tstate.events.set(name, list);\n\t}\n\tif (!state.dispatchers.has(name)) {\n\t\tconst dispatcher: EventListener = (event) => {\n\t\t\tconst args = getEventArgs(event);\n\t\t\tconst snapshot =\n\t\t\t\t(event as EventifyCustomEvent)[eventifyListenersKey] ??\n\t\t\t\tstate.events.get(name) ??\n\t\t\t\t[];\n\t\t\tfor (const listenerEntry of snapshot) {\n\t\t\t\tsafeCall(state, listenerEntry.callback, listenerEntry.ctx, args, {\n\t\t\t\t\tevent: name,\n\t\t\t\t\targs,\n\t\t\t\t\tlistener: listenerEntry.callback,\n\t\t\t\t\temitter,\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tstate.dispatchers.set(name, dispatcher);\n\t\tstate.target.addEventListener(name, dispatcher);\n\t}\n\tlist.push(entry);\n}\n\nfunction removeListener(\n\tstate: EmitterState,\n\tname: string,\n\tcallback?: CallbackWithOriginal | null,\n\tcontext?: unknown,\n): void {\n\tconst matches = (entry: ListenerEntry): boolean => {\n\t\tconst cb = callback as CallbackWithOriginal | null | undefined;\n\t\tconst cbMatches =\n\t\t\t!cb || cb === entry.callback || cb === entry.callback._callback;\n\t\tconst ctxMatches = !context || context === entry.context;\n\t\treturn cbMatches && ctxMatches;\n\t};\n\n\tconst removeFromList = (list: ListenerEntry[]): ListenerEntry[] => {\n\t\tconst retained: ListenerEntry[] = [];\n\t\tfor (const entry of list) {\n\t\t\tif (matches(entry)) {\n\t\t\t} else {\n\t\t\t\tretained.push(entry);\n\t\t\t}\n\t\t}\n\t\treturn retained;\n\t};\n\n\tif (name === \"all\") {\n\t\tstate.all = removeFromList(state.all);\n\t\treturn;\n\t}\n\tif (isPatternName(state, name)) {\n\t\tconst retained: PatternEntry[] = [];\n\t\tfor (const entry of state.patterns) {\n\t\t\tif (entry.pattern !== name || !matches(entry)) {\n\t\t\t\tretained.push(entry);\n\t\t\t}\n\t\t}\n\t\tstate.patterns = retained;\n\t\treturn;\n\t}\n\n\tconst list = state.events.get(name);\n\tif (!list) {\n\t\treturn;\n\t}\n\tconst retained = removeFromList(list);\n\tif (retained.length) {\n\t\tstate.events.set(name, retained);\n\t} else {\n\t\tstate.events.delete(name);\n\t\tconst dispatcher = state.dispatchers.get(name);\n\t\tif (dispatcher) {\n\t\t\tstate.target.removeEventListener(name, dispatcher);\n\t\t\tstate.dispatchers.delete(name);\n\t\t}\n\t}\n}\n\nfunction iterate(\n\tthis: AnyEmitter,\n\tname: \"all\",\n\toptions?: IterateOptions,\n): AsyncIterableIterator<[EventName<EventMap>, ...unknown[]]>;\nfunction iterate(\n\tthis: AnyEmitter,\n\tname: string,\n\toptions?: IterateOptions,\n): AsyncIterableIterator<unknown>;\nfunction iterate(\n\tthis: AnyEmitter,\n\tname: string,\n\toptions?: IterateOptions,\n): AsyncIterableIterator<unknown> {\n\tconst emitter = this as AnyEmitter;\n\tconst queue: unknown[] = [];\n\tlet pending: ((value: IteratorResult<unknown>) => void) | null = null;\n\tlet done = false;\n\tconst isAll = name === \"all\";\n\n\tconst handler = (...args: unknown[]) => {\n\t\tif (done) {\n\t\t\treturn;\n\t\t}\n\t\tconst value = isAll ? args : args.length === 1 ? args[0] : args;\n\t\tif (pending) {\n\t\t\tconst resolve = pending;\n\t\t\tpending = null;\n\t\t\tresolve({ value, done: false });\n\t\t\treturn;\n\t\t}\n\t\tqueue.push(value);\n\t};\n\n\temitter.on(name, handler);\n\n\tconst stop = () => {\n\t\tif (done) {\n\t\t\treturn;\n\t\t}\n\t\tdone = true;\n\t\temitter.off(name, handler);\n\t\tif (pending) {\n\t\t\tconst resolve = pending;\n\t\t\tpending = null;\n\t\t\tresolve({ value: undefined, done: true });\n\t\t}\n\t};\n\n\tif (options?.signal) {\n\t\tif (options.signal.aborted) {\n\t\t\tstop();\n\t\t} else {\n\t\t\toptions.signal.addEventListener(\"abort\", stop, { once: true });\n\t\t}\n\t}\n\n\tconst iterator: AsyncIterableIterator<unknown> = {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn iterator;\n\t\t},\n\t\tnext() {\n\t\t\tif (queue.length) {\n\t\t\t\tconst value = queue.shift() as unknown;\n\t\t\t\treturn Promise.resolve({ value, done: false });\n\t\t\t}\n\t\t\tif (done) {\n\t\t\t\treturn Promise.resolve({ value: undefined, done: true });\n\t\t\t}\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tpending = resolve;\n\t\t\t});\n\t\t},\n\t\treturn() {\n\t\t\tstop();\n\t\t\treturn Promise.resolve({ value: undefined, done: true });\n\t\t},\n\t\tthrow(error) {\n\t\t\tstop();\n\t\t\treturn Promise.reject(error);\n\t\t},\n\t};\n\n\treturn iterator;\n}\n\nconst proto: EventifyEmitter<EventMap> = {\n\taddEventListener(\n\t\tthis: AnyEmitter,\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject | null,\n\t\toptions?: boolean | AddEventListenerOptions,\n\t) {\n\t\tconst state = getState(this);\n\t\tstate.target.addEventListener(type, listener, options);\n\t\tif (listener) {\n\t\t\tconst listeners = state.nativeListeners.get(type) ?? new Set();\n\t\t\tlisteners.add(listener);\n\t\t\tstate.nativeListeners.set(type, listeners);\n\t\t}\n\t},\n\n\tremoveEventListener(\n\t\tthis: AnyEmitter,\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject | null,\n\t\toptions?: boolean | EventListenerOptions,\n\t) {\n\t\tconst state = getExistingState(this);\n\t\tif (!state) {\n\t\t\treturn;\n\t\t}\n\t\tstate.target.removeEventListener(type, listener, options);\n\t\tif (listener) {\n\t\t\tconst listeners = state.nativeListeners.get(type);\n\t\t\tif (listeners) {\n\t\t\t\tlisteners.delete(listener);\n\t\t\t\tif (!listeners.size) {\n\t\t\t\t\tstate.nativeListeners.delete(type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tdispatchEvent(this: AnyEmitter, event: Event) {\n\t\tconst state = getState(this);\n\t\treturn state.target.dispatchEvent(event);\n\t},\n\n\ton(this: AnyEmitter, name: unknown, callback?: unknown, context?: unknown) {\n\t\tif (!eventsApi(this, \"on\", name, [callback, context]) || !callback) {\n\t\t\treturn this;\n\t\t}\n\t\taddListener(\n\t\t\tthis,\n\t\t\tname as string,\n\t\t\tcallback as CallbackWithOriginal,\n\t\t\tcontext,\n\t\t);\n\t\treturn this;\n\t},\n\n\tonce(this: AnyEmitter, name: unknown, callback?: unknown, context?: unknown) {\n\t\tif (!eventsApi(this, \"once\", name, [callback, context]) || !callback) {\n\t\t\treturn this;\n\t\t}\n\t\tconst self = this as AnyEmitter;\n\t\tlet ran = false;\n\t\tconst onceListener: CallbackWithOriginal = function (\n\t\t\tthis: unknown,\n\t\t\t...args: unknown[]\n\t\t) {\n\t\t\tif (ran) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tran = true;\n\t\t\tself.off(name as string, onceListener, context);\n\t\t\treturn (callback as CallbackWithOriginal).apply(this, args);\n\t\t} as CallbackWithOriginal;\n\t\tonceListener._callback = callback as CallbackWithOriginal;\n\t\treturn (this as AnyEmitter).on(name as string, onceListener, context);\n\t},\n\n\toff(this: AnyEmitter, name?: unknown, callback?: unknown, context?: unknown) {\n\t\tconst state = getExistingState(this);\n\t\tif (!state || !eventsApi(this, \"off\", name, [callback, context])) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!name && !callback && !context) {\n\t\t\tfor (const [eventName, dispatcher] of state.dispatchers) {\n\t\t\t\tstate.target.removeEventListener(eventName, dispatcher);\n\t\t\t}\n\t\t\tstate.events.clear();\n\t\t\tstate.dispatchers.clear();\n\t\t\tstate.patterns = [];\n\t\t\tstate.all = [];\n\t\t\treturn this;\n\t\t}\n\n\t\tconst patternNames = new Set(state.patterns.map((entry) => entry.pattern));\n\t\tconst names = name\n\t\t\t? [name as string]\n\t\t\t: [\n\t\t\t\t\t...state.events.keys(),\n\t\t\t\t\t...patternNames,\n\t\t\t\t\t...(state.all.length ? [\"all\"] : []),\n\t\t\t\t];\n\n\t\tfor (const eventName of names) {\n\t\t\tremoveListener(\n\t\t\t\tstate,\n\t\t\t\teventName,\n\t\t\t\tcallback as CallbackWithOriginal,\n\t\t\t\tcontext,\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t},\n\n\ttrigger(this: AnyEmitter, name: unknown, ...args: unknown[]) {\n\t\tconst state = getExistingState(this);\n\t\tif (!state) {\n\t\t\treturn this;\n\t\t}\n\t\tif (!eventsApi(this, \"trigger\", name, args)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tconst eventName = name as string;\n\t\tconst validatedArgs = normalizeValidatedArgs(state, eventName, args);\n\n\t\tconst eventSnapshot = state.events.get(eventName)?.slice() ?? null;\n\t\tconst patternSnapshot = state.patterns.length\n\t\t\t? state.patterns.slice()\n\t\t\t: null;\n\t\tconst allSnapshot = state.all.length ? state.all.slice() : null;\n\t\tlet eventSegments: string[] | null = null;\n\n\t\tconst hasNativeListeners = state.nativeListeners.get(eventName)?.size;\n\t\tif (hasNativeListeners) {\n\t\t\tconst event = createEvent(eventName, validatedArgs);\n\t\t\tif (eventSnapshot?.length) {\n\t\t\t\tObject.defineProperty(event, eventifyListenersKey, {\n\t\t\t\t\tvalue: eventSnapshot,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t});\n\t\t\t}\n\t\t\tstate.target.dispatchEvent(event);\n\t\t} else if (eventSnapshot?.length) {\n\t\t\tfor (const entry of eventSnapshot) {\n\t\t\t\tsafeCall(state, entry.callback, entry.ctx, validatedArgs, {\n\t\t\t\t\tevent: eventName,\n\t\t\t\t\targs: validatedArgs,\n\t\t\t\t\tlistener: entry.callback,\n\t\t\t\t\temitter: this,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (patternSnapshot) {\n\t\t\tfor (const entry of patternSnapshot) {\n\t\t\t\tif (entry.match === \"prefix\") {\n\t\t\t\t\tif (!eventName.startsWith(entry.prefix)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!eventSegments) {\n\t\t\t\t\t\teventSegments = splitName(eventName, state.namespaceDelimiter);\n\t\t\t\t\t}\n\t\t\t\t\tif (!matchesPatternSegments(state, entry, eventSegments)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsafeCall(state, entry.callback, entry.ctx, validatedArgs, {\n\t\t\t\t\tevent: eventName,\n\t\t\t\t\targs: validatedArgs,\n\t\t\t\t\tlistener: entry.callback,\n\t\t\t\t\temitter: this,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (allSnapshot) {\n\t\t\tfor (const entry of allSnapshot) {\n\t\t\t\tsafeCall(\n\t\t\t\t\tstate,\n\t\t\t\t\tentry.callback,\n\t\t\t\t\tentry.ctx,\n\t\t\t\t\t[eventName, ...validatedArgs],\n\t\t\t\t\t{\n\t\t\t\t\t\tevent: eventName,\n\t\t\t\t\t\targs: validatedArgs,\n\t\t\t\t\t\tlistener: entry.callback,\n\t\t\t\t\t\temitter: this,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\temit(this: AnyEmitter, name: unknown, ...args: unknown[]) {\n\t\treturn (this as AnyEmitter).trigger(name as string, ...args);\n\t},\n\n\tproduce(this: AnyEmitter, name: unknown, ...args: unknown[]) {\n\t\treturn (this as AnyEmitter).trigger(name as string, ...args);\n\t},\n\n\tlistenTo(this: AnyEmitter, obj: unknown, name: unknown, callback?: unknown) {\n\t\tif (!obj) {\n\t\t\treturn this;\n\t\t}\n\t\tconst state = getState(this);\n\t\tstate.listeningTo.add(obj as AnyEmitter);\n\t\tif (name && typeof name === \"object\") {\n\t\t\tcallback = this;\n\t\t}\n\t\tconst target = obj as AnyEmitter;\n\t\tif (name && typeof name === \"object\") {\n\t\t\ttarget.on(name as EventHandlerMap<EventMap>, this);\n\t\t} else {\n\t\t\ttarget.on(\n\t\t\t\tname as string,\n\t\t\t\tcallback as CallbackWithOriginal | undefined,\n\t\t\t\tthis,\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t},\n\n\tlistenToOnce(\n\t\tthis: AnyEmitter,\n\t\tobj: unknown,\n\t\tname: unknown,\n\t\tcallback?: unknown,\n\t) {\n\t\tif (!obj) {\n\t\t\treturn this;\n\t\t}\n\t\tconst state = getState(this);\n\t\tstate.listeningTo.add(obj as AnyEmitter);\n\t\tif (name && typeof name === \"object\") {\n\t\t\tcallback = this;\n\t\t}\n\t\tconst target = obj as AnyEmitter;\n\t\tif (name && typeof name === \"object\") {\n\t\t\ttarget.once(name as EventHandlerMap<EventMap>, this);\n\t\t} else {\n\t\t\ttarget.once(\n\t\t\t\tname as string,\n\t\t\t\tcallback as CallbackWithOriginal | undefined,\n\t\t\t\tthis,\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t},\n\n\tstopListening(\n\t\tthis: AnyEmitter,\n\t\tobj?: unknown,\n\t\tname?: unknown,\n\t\tcallback?: unknown,\n\t) {\n\t\tconst state = getExistingState(this);\n\t\tif (!state) {\n\t\t\treturn this;\n\t\t}\n\t\tconst deleteListener = !name && !callback;\n\t\tif (name && typeof name === \"object\") {\n\t\t\tcallback = this;\n\t\t}\n\n\t\tconst targets: AnyEmitter[] = [];\n\t\tif (obj) {\n\t\t\ttargets.push(obj as AnyEmitter);\n\t\t} else {\n\t\t\ttargets.push(...state.listeningTo.values());\n\t\t}\n\n\t\tfor (const target of targets) {\n\t\t\tif (name && typeof name === \"object\") {\n\t\t\t\ttarget.off(name as EventHandlerMap<EventMap>, this);\n\t\t\t} else {\n\t\t\t\ttarget.off(\n\t\t\t\t\tname as string | null | undefined,\n\t\t\t\t\tcallback as CallbackWithOriginal | null | undefined,\n\t\t\t\t\tthis,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (deleteListener) {\n\t\t\t\tstate.listeningTo.delete(target);\n\t\t\t}\n\t\t}\n\t\tif (deleteListener && !obj) {\n\t\t\tstate.listeningTo.clear();\n\t\t}\n\t\treturn this;\n\t},\n\n\titerate,\n};\n\nexport function createEventify<TSchemas extends SchemaMap>(\n\toptions: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & {\n\t\tschemas: TSchemas;\n\t},\n): EventifyEmitter<EventsFromSchemas<TSchemas>>;\nexport function createEventify<\n\tTEvents extends EventMap = EventMap,\n\tTSchemas extends SchemaMap | undefined = undefined,\n>(options?: EventifyOptions<TSchemas, TEvents>): EventifyEmitter<TEvents>;\nexport function createEventify(\n\toptions?: EventifyOptions,\n): EventifyEmitter<EventMap> {\n\tconst emitter = Object.create(proto) as EventifyEmitter<EventMap>;\n\tgetState(emitter, options as EventifyOptions);\n\treturn emitter;\n}\n\nexport function enable<TTarget extends object, TSchemas extends SchemaMap>(\n\ttarget: TTarget | undefined,\n\toptions: EventifyOptions<TSchemas, EventsFromSchemas<TSchemas>> & {\n\t\tschemas: TSchemas;\n\t},\n): TTarget & EventifyEmitter<EventsFromSchemas<TSchemas>>;\nexport function enable<\n\tTTarget extends object,\n\tTEvents extends EventMap = EventMap,\n\tTSchemas extends SchemaMap | undefined = undefined,\n>(\n\ttarget?: TTarget,\n\toptions?: EventifyOptions<TSchemas, TEvents>,\n): TTarget & EventifyEmitter<TEvents>;\nexport function enable(\n\ttarget?: object,\n\toptions?: EventifyOptions,\n): object & EventifyEmitter<EventMap> {\n\tconst destination = (target ?? {}) as Record<string, unknown>;\n\tconst protoMethods = proto as unknown as Record<string, unknown>;\n\tfor (const method of Object.keys(proto)) {\n\t\tdestination[method] = protoMethods[method];\n\t}\n\tgetState(destination, options as EventifyOptions);\n\treturn destination as unknown as object & EventifyEmitter<EventMap>;\n}\n\nconst EventifyInstance = createEventify();\n\nconst Eventify = Object.assign(EventifyInstance, {\n\tversion: \"3.0.0\",\n\tenable,\n\tcreate: createEventify,\n\tmixin: enable,\n\tproto,\n\tnoConflict: () => Eventify as EventifyStatic,\n\tdefaultSchemaValidator,\n}) as EventifyStatic;\n\nconst createEmitter = createEventify;\nconst decorateWithEvents = enable;\nconst setDefaultSchemaValidator = defaultSchemaValidator;\n\nexport {\n\tEventify,\n\tcreateEmitter,\n\tdecorateWithEvents,\n\tsetDefaultSchemaValidator,\n};\nexport default Eventify;\n"
  ],
  "mappings": "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",
  "debugId": "CC1457DA4423BE7364756E2164756E21",
  "names": []
}